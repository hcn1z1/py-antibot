import numpy as np
from sklearn.preprocessing import PolynomialFeatures
from sklearn.kernel_ridge import KernelRidge
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score,mean_squared_error
from sklearn.pipeline import make_pipeline


def linear_regression(x_train, y_train, x_test, y_test):
    model = LinearRegression()
    model.fit(x_train, y_train)
    y_pred = model.predict(x_test)
    mse = mean_squared_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)
    print("Linear Regression MSE:", mse)
    print("Linear Regression R^2 score:", r2)
    return model,r2

def polynomial_regression(x_train, y_train, x_test, y_test, degree=2):
    model = make_pipeline(PolynomialFeatures(degree), LinearRegression())
    model.fit(x_train, y_train)
    y_pred = model.predict(x_test)
    mse = mean_squared_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)
    print("Polynomial Regression MSE for degree", degree, ":", mse)
    print("Polynomial Regression R^2 score for degree", degree, ":", r2)
    return model,r2

def nonlinear_regression(x_train, y_train, x_test, y_test, kernel='rbf'):
    model = KernelRidge(kernel=kernel)
    model.fit(x_train, y_train)
    y_pred = model.predict(x_test)
    mse = mean_squared_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)
    print("Non-linear Regression MSE with", kernel, "kernel:", mse)
    print("Non-linear Regression R^2 score with", kernel, "kernel:", r2)
    return model,r2


def generate_score(r2,initial_score = 1,f_digit = 2):
    income_accuracy = float(format(r2,f".{f_digit}f"))
    estimated_error = abs(float(format(1 - r2,f".{f_digit}f")))
    if estimated_error > 1 : return 0 
    return float(format((initial_score - estimated_error)*income_accuracy,f".2f"))

def predict_upcoming(x:list,y:list) -> float:
    """
    Predicts the likelihood of an entity being a bot based on linear and nonlinear regression analyses of provided coordinates.

    Parameters:
    x (list): A list of x-coordinates. These are expected to be numerical values that represent features or behavior patterns over time.
    y (list): A list of y-coordinates corresponding to the x-coordinates. These values are typically the outputs or responses and are used to train the regression models.

    This function first splits the data into training and testing subsets. Then, it performs three types of regression:
    1. Linear regression
    2. Polynomial regression with a degree of 3
    3. Non-linear regression using a Radial Basis Function (RBF) kernel

    Each model's performance is evaluated using the R-squared statistic, which measures the proportion of variance in the dependent variable that is predictable from the independent variables.

    A composite 'bot score' is calculated by assigning different weights to the R-squared values obtained from each regression model. This score is used to determine the likelihood of the observed behavior pattern being generated by a bot.

    Returns:
    int: A score that quantifies the likelihood of the entity being a bot. Higher scores indicate a higher likelihood of bot-like behavior.
    """
    x = np.array(x).reshape(-1, 1)
    y = np.array(y).flatten()
    split_index = int(0.8 * len(x))
    x_train, x_test = x[:split_index], x[split_index:]
    y_train, y_test = y[:split_index], y[split_index:]
    linear_model,r2_linear = linear_regression(x_train, y_train, x_test, y_test)
    poly_model,r2_poly = polynomial_regression(x_train, y_train, x_test, y_test, degree=3)
    nonlinear_model,r2_nonlinear = nonlinear_regression(x_train, y_train, x_test, y_test, kernel='rbf')
    score = sum([generate_score(r2_linear,2,5),generate_score(r2_poly,1,5),generate_score(r2_nonlinear,0.3,2)]) # generate bot score. this score can determine If we detected a bot or not
    return score